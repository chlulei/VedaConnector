<?php
/**
 * VeranstaltungsterminreihenApi
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * VEDA Bildungsmanager API
 *
 * Dokumentation der REST-Schnittstellen des VEDA Bildungsmanagers für die Version 2. Die Dokumentation zu speziellen Versionen kann über die Angabe des zusätzlichen Parameters \"group\" angezeigt werden. Beispiel: .../api/docs?group=v1 für die Dokumentation der Version 1, die aktuelle Version ist unter .../api/docs erreichbar.
 *
 * OpenAPI spec version: 2
 * Contact: info@veda.net
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.21
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Swagger\Client\ApiException;
use Swagger\Client\Configuration;
use Swagger\Client\HeaderSelector;
use Swagger\Client\ObjectSerializer;

/**
 * VeranstaltungsterminreihenApi Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class VeranstaltungsterminreihenApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation getVeranstaltungsterminreiheUsingGET
     *
     * Ruft eine Veranstaltungsterminreihe ab (entweder nicht storniert oder storniert)
     *
     * @param  string $id ID der Veranstaltungsterminreihe (required)
     * @param  bool $stornierte_veranstaltungsterminreihe_abrufen Optionaler Parameter, um zu steuern, ob eine stornierte oder eine nicht stornierte Veranstaltungsterminreihe abgerufen werden soll. Der Default ist false. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Veranstaltungsterminreihe
     */
    public function getVeranstaltungsterminreiheUsingGET($id, $stornierte_veranstaltungsterminreihe_abrufen = null)
    {
        list($response) = $this->getVeranstaltungsterminreiheUsingGETWithHttpInfo($id, $stornierte_veranstaltungsterminreihe_abrufen);
        return $response;
    }

    /**
     * Operation getVeranstaltungsterminreiheUsingGETWithHttpInfo
     *
     * Ruft eine Veranstaltungsterminreihe ab (entweder nicht storniert oder storniert)
     *
     * @param  string $id ID der Veranstaltungsterminreihe (required)
     * @param  bool $stornierte_veranstaltungsterminreihe_abrufen Optionaler Parameter, um zu steuern, ob eine stornierte oder eine nicht stornierte Veranstaltungsterminreihe abgerufen werden soll. Der Default ist false. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Veranstaltungsterminreihe, HTTP status code, HTTP response headers (array of strings)
     */
    public function getVeranstaltungsterminreiheUsingGETWithHttpInfo($id, $stornierte_veranstaltungsterminreihe_abrufen = null)
    {
        $returnType = '\Swagger\Client\Model\Veranstaltungsterminreihe';
        $request = $this->getVeranstaltungsterminreiheUsingGETRequest($id, $stornierte_veranstaltungsterminreihe_abrufen);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Veranstaltungsterminreihe',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getVeranstaltungsterminreiheUsingGETAsync
     *
     * Ruft eine Veranstaltungsterminreihe ab (entweder nicht storniert oder storniert)
     *
     * @param  string $id ID der Veranstaltungsterminreihe (required)
     * @param  bool $stornierte_veranstaltungsterminreihe_abrufen Optionaler Parameter, um zu steuern, ob eine stornierte oder eine nicht stornierte Veranstaltungsterminreihe abgerufen werden soll. Der Default ist false. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVeranstaltungsterminreiheUsingGETAsync($id, $stornierte_veranstaltungsterminreihe_abrufen = null)
    {
        return $this->getVeranstaltungsterminreiheUsingGETAsyncWithHttpInfo($id, $stornierte_veranstaltungsterminreihe_abrufen)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getVeranstaltungsterminreiheUsingGETAsyncWithHttpInfo
     *
     * Ruft eine Veranstaltungsterminreihe ab (entweder nicht storniert oder storniert)
     *
     * @param  string $id ID der Veranstaltungsterminreihe (required)
     * @param  bool $stornierte_veranstaltungsterminreihe_abrufen Optionaler Parameter, um zu steuern, ob eine stornierte oder eine nicht stornierte Veranstaltungsterminreihe abgerufen werden soll. Der Default ist false. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVeranstaltungsterminreiheUsingGETAsyncWithHttpInfo($id, $stornierte_veranstaltungsterminreihe_abrufen = null)
    {
        $returnType = '\Swagger\Client\Model\Veranstaltungsterminreihe';
        $request = $this->getVeranstaltungsterminreiheUsingGETRequest($id, $stornierte_veranstaltungsterminreihe_abrufen);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getVeranstaltungsterminreiheUsingGET'
     *
     * @param  string $id ID der Veranstaltungsterminreihe (required)
     * @param  bool $stornierte_veranstaltungsterminreihe_abrufen Optionaler Parameter, um zu steuern, ob eine stornierte oder eine nicht stornierte Veranstaltungsterminreihe abgerufen werden soll. Der Default ist false. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getVeranstaltungsterminreiheUsingGETRequest($id, $stornierte_veranstaltungsterminreihe_abrufen = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getVeranstaltungsterminreiheUsingGET'
            );
        }

        $resourcePath = '/v2/veranstaltungsterminreihen/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($stornierte_veranstaltungsterminreihe_abrufen !== null) {
            $queryParams['stornierteVeranstaltungsterminreiheAbrufen'] = ObjectSerializer::toQueryValue($stornierte_veranstaltungsterminreihe_abrufen);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getVeranstaltungsterminreiheUsingGET1
     *
     * Ruft eine Veranstaltungsterminreihe ab (entweder nicht storniert oder storniert)
     *
     * @param  string $id ID der Veranstaltungsterminreihe (required)
     * @param  bool $stornierte_veranstaltungsterminreihe_abrufen Optionaler Parameter, um zu steuern, ob eine stornierte oder eine nicht stornierte Veranstaltungsterminreihe abgerufen werden soll. Der Default ist false. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Veranstaltungsterminreihe
     */
    public function getVeranstaltungsterminreiheUsingGET1($id, $stornierte_veranstaltungsterminreihe_abrufen = null)
    {
        list($response) = $this->getVeranstaltungsterminreiheUsingGET1WithHttpInfo($id, $stornierte_veranstaltungsterminreihe_abrufen);
        return $response;
    }

    /**
     * Operation getVeranstaltungsterminreiheUsingGET1WithHttpInfo
     *
     * Ruft eine Veranstaltungsterminreihe ab (entweder nicht storniert oder storniert)
     *
     * @param  string $id ID der Veranstaltungsterminreihe (required)
     * @param  bool $stornierte_veranstaltungsterminreihe_abrufen Optionaler Parameter, um zu steuern, ob eine stornierte oder eine nicht stornierte Veranstaltungsterminreihe abgerufen werden soll. Der Default ist false. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Veranstaltungsterminreihe, HTTP status code, HTTP response headers (array of strings)
     */
    public function getVeranstaltungsterminreiheUsingGET1WithHttpInfo($id, $stornierte_veranstaltungsterminreihe_abrufen = null)
    {
        $returnType = '\Swagger\Client\Model\Veranstaltungsterminreihe';
        $request = $this->getVeranstaltungsterminreiheUsingGET1Request($id, $stornierte_veranstaltungsterminreihe_abrufen);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Veranstaltungsterminreihe',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getVeranstaltungsterminreiheUsingGET1Async
     *
     * Ruft eine Veranstaltungsterminreihe ab (entweder nicht storniert oder storniert)
     *
     * @param  string $id ID der Veranstaltungsterminreihe (required)
     * @param  bool $stornierte_veranstaltungsterminreihe_abrufen Optionaler Parameter, um zu steuern, ob eine stornierte oder eine nicht stornierte Veranstaltungsterminreihe abgerufen werden soll. Der Default ist false. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVeranstaltungsterminreiheUsingGET1Async($id, $stornierte_veranstaltungsterminreihe_abrufen = null)
    {
        return $this->getVeranstaltungsterminreiheUsingGET1AsyncWithHttpInfo($id, $stornierte_veranstaltungsterminreihe_abrufen)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getVeranstaltungsterminreiheUsingGET1AsyncWithHttpInfo
     *
     * Ruft eine Veranstaltungsterminreihe ab (entweder nicht storniert oder storniert)
     *
     * @param  string $id ID der Veranstaltungsterminreihe (required)
     * @param  bool $stornierte_veranstaltungsterminreihe_abrufen Optionaler Parameter, um zu steuern, ob eine stornierte oder eine nicht stornierte Veranstaltungsterminreihe abgerufen werden soll. Der Default ist false. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVeranstaltungsterminreiheUsingGET1AsyncWithHttpInfo($id, $stornierte_veranstaltungsterminreihe_abrufen = null)
    {
        $returnType = '\Swagger\Client\Model\Veranstaltungsterminreihe';
        $request = $this->getVeranstaltungsterminreiheUsingGET1Request($id, $stornierte_veranstaltungsterminreihe_abrufen);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getVeranstaltungsterminreiheUsingGET1'
     *
     * @param  string $id ID der Veranstaltungsterminreihe (required)
     * @param  bool $stornierte_veranstaltungsterminreihe_abrufen Optionaler Parameter, um zu steuern, ob eine stornierte oder eine nicht stornierte Veranstaltungsterminreihe abgerufen werden soll. Der Default ist false. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getVeranstaltungsterminreiheUsingGET1Request($id, $stornierte_veranstaltungsterminreihe_abrufen = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getVeranstaltungsterminreiheUsingGET1'
            );
        }

        $resourcePath = '/v2/20010/veranstaltungsterminreihen/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($stornierte_veranstaltungsterminreihe_abrufen !== null) {
            $queryParams['stornierteVeranstaltungsterminreiheAbrufen'] = ObjectSerializer::toQueryValue($stornierte_veranstaltungsterminreihe_abrufen);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getVeranstaltungsterminreihenUsingGET
     *
     * Ruft Veranstaltungsterminreihen ab (entweder nicht stornierte oder stornierte)
     *
     * @param  \DateTime $modifiziert_ab Änderungs- bzw. Einfügezeitpunkt, ab dem die Veranstaltungsterminreihen geliefert werden sollen. Das Format muss wie folgt sein: yyyy-MM-ddTHH:mm:ss.SSS (optional)
     * @param  bool $stornierte_veranstaltungsterminreihen_abrufen Optionaler Parameter, um zu steuern, ob stornierte oder nicht stornierte Veranstaltungsterminreihen abgerufen werden sollen. Der Default ist false. (optional)
     * @param  string $veranstaltungstyp_id Optionaler Parameter, um nur Veranstaltungsterminreihen eines bestimmten Veranstaltungstyps abzurufen. Beispiel-ID: cfa1403a-13c6-4681-8ee3-e30127554845 (optional)
     * @param  string $teilnehmergruppekuerzel Optionaler Parameter, um zu steuern, für welche Teilnehmergruppe die Veranstaltungsterminreihen abgerufen werden sollen. Ist eine Teilnehmergruppe angegeben, so werden alle in der Zukunft liegenden und publizierten Veranstaltungsterminreihen für diese Teilnehmergruppe zurückgegeben. (optional)
     * @param  string $veranstaltungskategorie_id Optionaler Parameter, um Veranstaltungsterminreihen nach einer Veranstaltungskategorie zu filtern. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Veranstaltungsterminreihe[]
     */
    public function getVeranstaltungsterminreihenUsingGET($modifiziert_ab = null, $stornierte_veranstaltungsterminreihen_abrufen = null, $veranstaltungstyp_id = null, $teilnehmergruppekuerzel = null, $veranstaltungskategorie_id = null)
    {
        list($response) = $this->getVeranstaltungsterminreihenUsingGETWithHttpInfo($modifiziert_ab, $stornierte_veranstaltungsterminreihen_abrufen, $veranstaltungstyp_id, $teilnehmergruppekuerzel, $veranstaltungskategorie_id);
        return $response;
    }

    /**
     * Operation getVeranstaltungsterminreihenUsingGETWithHttpInfo
     *
     * Ruft Veranstaltungsterminreihen ab (entweder nicht stornierte oder stornierte)
     *
     * @param  \DateTime $modifiziert_ab Änderungs- bzw. Einfügezeitpunkt, ab dem die Veranstaltungsterminreihen geliefert werden sollen. Das Format muss wie folgt sein: yyyy-MM-ddTHH:mm:ss.SSS (optional)
     * @param  bool $stornierte_veranstaltungsterminreihen_abrufen Optionaler Parameter, um zu steuern, ob stornierte oder nicht stornierte Veranstaltungsterminreihen abgerufen werden sollen. Der Default ist false. (optional)
     * @param  string $veranstaltungstyp_id Optionaler Parameter, um nur Veranstaltungsterminreihen eines bestimmten Veranstaltungstyps abzurufen. Beispiel-ID: cfa1403a-13c6-4681-8ee3-e30127554845 (optional)
     * @param  string $teilnehmergruppekuerzel Optionaler Parameter, um zu steuern, für welche Teilnehmergruppe die Veranstaltungsterminreihen abgerufen werden sollen. Ist eine Teilnehmergruppe angegeben, so werden alle in der Zukunft liegenden und publizierten Veranstaltungsterminreihen für diese Teilnehmergruppe zurückgegeben. (optional)
     * @param  string $veranstaltungskategorie_id Optionaler Parameter, um Veranstaltungsterminreihen nach einer Veranstaltungskategorie zu filtern. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Veranstaltungsterminreihe[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getVeranstaltungsterminreihenUsingGETWithHttpInfo($modifiziert_ab = null, $stornierte_veranstaltungsterminreihen_abrufen = null, $veranstaltungstyp_id = null, $teilnehmergruppekuerzel = null, $veranstaltungskategorie_id = null)
    {
        $returnType = '\Swagger\Client\Model\Veranstaltungsterminreihe[]';
        $request = $this->getVeranstaltungsterminreihenUsingGETRequest($modifiziert_ab, $stornierte_veranstaltungsterminreihen_abrufen, $veranstaltungstyp_id, $teilnehmergruppekuerzel, $veranstaltungskategorie_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Veranstaltungsterminreihe[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getVeranstaltungsterminreihenUsingGETAsync
     *
     * Ruft Veranstaltungsterminreihen ab (entweder nicht stornierte oder stornierte)
     *
     * @param  \DateTime $modifiziert_ab Änderungs- bzw. Einfügezeitpunkt, ab dem die Veranstaltungsterminreihen geliefert werden sollen. Das Format muss wie folgt sein: yyyy-MM-ddTHH:mm:ss.SSS (optional)
     * @param  bool $stornierte_veranstaltungsterminreihen_abrufen Optionaler Parameter, um zu steuern, ob stornierte oder nicht stornierte Veranstaltungsterminreihen abgerufen werden sollen. Der Default ist false. (optional)
     * @param  string $veranstaltungstyp_id Optionaler Parameter, um nur Veranstaltungsterminreihen eines bestimmten Veranstaltungstyps abzurufen. Beispiel-ID: cfa1403a-13c6-4681-8ee3-e30127554845 (optional)
     * @param  string $teilnehmergruppekuerzel Optionaler Parameter, um zu steuern, für welche Teilnehmergruppe die Veranstaltungsterminreihen abgerufen werden sollen. Ist eine Teilnehmergruppe angegeben, so werden alle in der Zukunft liegenden und publizierten Veranstaltungsterminreihen für diese Teilnehmergruppe zurückgegeben. (optional)
     * @param  string $veranstaltungskategorie_id Optionaler Parameter, um Veranstaltungsterminreihen nach einer Veranstaltungskategorie zu filtern. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVeranstaltungsterminreihenUsingGETAsync($modifiziert_ab = null, $stornierte_veranstaltungsterminreihen_abrufen = null, $veranstaltungstyp_id = null, $teilnehmergruppekuerzel = null, $veranstaltungskategorie_id = null)
    {
        return $this->getVeranstaltungsterminreihenUsingGETAsyncWithHttpInfo($modifiziert_ab, $stornierte_veranstaltungsterminreihen_abrufen, $veranstaltungstyp_id, $teilnehmergruppekuerzel, $veranstaltungskategorie_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getVeranstaltungsterminreihenUsingGETAsyncWithHttpInfo
     *
     * Ruft Veranstaltungsterminreihen ab (entweder nicht stornierte oder stornierte)
     *
     * @param  \DateTime $modifiziert_ab Änderungs- bzw. Einfügezeitpunkt, ab dem die Veranstaltungsterminreihen geliefert werden sollen. Das Format muss wie folgt sein: yyyy-MM-ddTHH:mm:ss.SSS (optional)
     * @param  bool $stornierte_veranstaltungsterminreihen_abrufen Optionaler Parameter, um zu steuern, ob stornierte oder nicht stornierte Veranstaltungsterminreihen abgerufen werden sollen. Der Default ist false. (optional)
     * @param  string $veranstaltungstyp_id Optionaler Parameter, um nur Veranstaltungsterminreihen eines bestimmten Veranstaltungstyps abzurufen. Beispiel-ID: cfa1403a-13c6-4681-8ee3-e30127554845 (optional)
     * @param  string $teilnehmergruppekuerzel Optionaler Parameter, um zu steuern, für welche Teilnehmergruppe die Veranstaltungsterminreihen abgerufen werden sollen. Ist eine Teilnehmergruppe angegeben, so werden alle in der Zukunft liegenden und publizierten Veranstaltungsterminreihen für diese Teilnehmergruppe zurückgegeben. (optional)
     * @param  string $veranstaltungskategorie_id Optionaler Parameter, um Veranstaltungsterminreihen nach einer Veranstaltungskategorie zu filtern. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVeranstaltungsterminreihenUsingGETAsyncWithHttpInfo($modifiziert_ab = null, $stornierte_veranstaltungsterminreihen_abrufen = null, $veranstaltungstyp_id = null, $teilnehmergruppekuerzel = null, $veranstaltungskategorie_id = null)
    {
        $returnType = '\Swagger\Client\Model\Veranstaltungsterminreihe[]';
        $request = $this->getVeranstaltungsterminreihenUsingGETRequest($modifiziert_ab, $stornierte_veranstaltungsterminreihen_abrufen, $veranstaltungstyp_id, $teilnehmergruppekuerzel, $veranstaltungskategorie_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getVeranstaltungsterminreihenUsingGET'
     *
     * @param  \DateTime $modifiziert_ab Änderungs- bzw. Einfügezeitpunkt, ab dem die Veranstaltungsterminreihen geliefert werden sollen. Das Format muss wie folgt sein: yyyy-MM-ddTHH:mm:ss.SSS (optional)
     * @param  bool $stornierte_veranstaltungsterminreihen_abrufen Optionaler Parameter, um zu steuern, ob stornierte oder nicht stornierte Veranstaltungsterminreihen abgerufen werden sollen. Der Default ist false. (optional)
     * @param  string $veranstaltungstyp_id Optionaler Parameter, um nur Veranstaltungsterminreihen eines bestimmten Veranstaltungstyps abzurufen. Beispiel-ID: cfa1403a-13c6-4681-8ee3-e30127554845 (optional)
     * @param  string $teilnehmergruppekuerzel Optionaler Parameter, um zu steuern, für welche Teilnehmergruppe die Veranstaltungsterminreihen abgerufen werden sollen. Ist eine Teilnehmergruppe angegeben, so werden alle in der Zukunft liegenden und publizierten Veranstaltungsterminreihen für diese Teilnehmergruppe zurückgegeben. (optional)
     * @param  string $veranstaltungskategorie_id Optionaler Parameter, um Veranstaltungsterminreihen nach einer Veranstaltungskategorie zu filtern. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getVeranstaltungsterminreihenUsingGETRequest($modifiziert_ab = null, $stornierte_veranstaltungsterminreihen_abrufen = null, $veranstaltungstyp_id = null, $teilnehmergruppekuerzel = null, $veranstaltungskategorie_id = null)
    {

        $resourcePath = '/v2/veranstaltungsterminreihen';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($modifiziert_ab !== null) {
            $queryParams['modifiziertAb'] = ObjectSerializer::toQueryValue($modifiziert_ab);
        }
        // query params
        if ($stornierte_veranstaltungsterminreihen_abrufen !== null) {
            $queryParams['stornierteVeranstaltungsterminreihenAbrufen'] = ObjectSerializer::toQueryValue($stornierte_veranstaltungsterminreihen_abrufen);
        }
        // query params
        if ($veranstaltungstyp_id !== null) {
            $queryParams['veranstaltungstypID'] = ObjectSerializer::toQueryValue($veranstaltungstyp_id);
        }
        // query params
        if ($teilnehmergruppekuerzel !== null) {
            $queryParams['teilnehmergruppekuerzel'] = ObjectSerializer::toQueryValue($teilnehmergruppekuerzel);
        }
        // query params
        if ($veranstaltungskategorie_id !== null) {
            $queryParams['veranstaltungskategorieId'] = ObjectSerializer::toQueryValue($veranstaltungskategorie_id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getVeranstaltungsterminreihenUsingGET1
     *
     * Ruft Veranstaltungsterminreihen ab (entweder nicht stornierte oder stornierte)
     *
     * @param  \DateTime $modifiziert_ab Änderungs- bzw. Einfügezeitpunkt, ab dem die Veranstaltungsterminreihen geliefert werden sollen. Das Format muss wie folgt sein: yyyy-MM-ddTHH:mm:ss.SSS (optional)
     * @param  bool $stornierte_veranstaltungsterminreihen_abrufen Optionaler Parameter, um zu steuern, ob stornierte oder nicht stornierte Veranstaltungsterminreihen abgerufen werden sollen. Der Default ist false. (optional)
     * @param  string $veranstaltungstyp_id Optionaler Parameter, um nur Veranstaltungsterminreihen eines bestimmten Veranstaltungstyps abzurufen. Beispiel-ID: cfa1403a-13c6-4681-8ee3-e30127554845 (optional)
     * @param  string $teilnehmergruppekuerzel Optionaler Parameter, um zu steuern, für welche Teilnehmergruppe die Veranstaltungsterminreihen abgerufen werden sollen. Ist eine Teilnehmergruppe angegeben, so werden alle in der Zukunft liegenden und publizierten Veranstaltungsterminreihen für diese Teilnehmergruppe zurückgegeben. (optional)
     * @param  string $veranstaltungskategorie_id Optionaler Parameter, um Veranstaltungsterminreihen nach einer Veranstaltungskategorie zu filtern. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Veranstaltungsterminreihe[]
     */
    public function getVeranstaltungsterminreihenUsingGET1($modifiziert_ab = null, $stornierte_veranstaltungsterminreihen_abrufen = null, $veranstaltungstyp_id = null, $teilnehmergruppekuerzel = null, $veranstaltungskategorie_id = null)
    {
        list($response) = $this->getVeranstaltungsterminreihenUsingGET1WithHttpInfo($modifiziert_ab, $stornierte_veranstaltungsterminreihen_abrufen, $veranstaltungstyp_id, $teilnehmergruppekuerzel, $veranstaltungskategorie_id);
        return $response;
    }

    /**
     * Operation getVeranstaltungsterminreihenUsingGET1WithHttpInfo
     *
     * Ruft Veranstaltungsterminreihen ab (entweder nicht stornierte oder stornierte)
     *
     * @param  \DateTime $modifiziert_ab Änderungs- bzw. Einfügezeitpunkt, ab dem die Veranstaltungsterminreihen geliefert werden sollen. Das Format muss wie folgt sein: yyyy-MM-ddTHH:mm:ss.SSS (optional)
     * @param  bool $stornierte_veranstaltungsterminreihen_abrufen Optionaler Parameter, um zu steuern, ob stornierte oder nicht stornierte Veranstaltungsterminreihen abgerufen werden sollen. Der Default ist false. (optional)
     * @param  string $veranstaltungstyp_id Optionaler Parameter, um nur Veranstaltungsterminreihen eines bestimmten Veranstaltungstyps abzurufen. Beispiel-ID: cfa1403a-13c6-4681-8ee3-e30127554845 (optional)
     * @param  string $teilnehmergruppekuerzel Optionaler Parameter, um zu steuern, für welche Teilnehmergruppe die Veranstaltungsterminreihen abgerufen werden sollen. Ist eine Teilnehmergruppe angegeben, so werden alle in der Zukunft liegenden und publizierten Veranstaltungsterminreihen für diese Teilnehmergruppe zurückgegeben. (optional)
     * @param  string $veranstaltungskategorie_id Optionaler Parameter, um Veranstaltungsterminreihen nach einer Veranstaltungskategorie zu filtern. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Veranstaltungsterminreihe[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getVeranstaltungsterminreihenUsingGET1WithHttpInfo($modifiziert_ab = null, $stornierte_veranstaltungsterminreihen_abrufen = null, $veranstaltungstyp_id = null, $teilnehmergruppekuerzel = null, $veranstaltungskategorie_id = null)
    {
        $returnType = '\Swagger\Client\Model\Veranstaltungsterminreihe[]';
        $request = $this->getVeranstaltungsterminreihenUsingGET1Request($modifiziert_ab, $stornierte_veranstaltungsterminreihen_abrufen, $veranstaltungstyp_id, $teilnehmergruppekuerzel, $veranstaltungskategorie_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Veranstaltungsterminreihe[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getVeranstaltungsterminreihenUsingGET1Async
     *
     * Ruft Veranstaltungsterminreihen ab (entweder nicht stornierte oder stornierte)
     *
     * @param  \DateTime $modifiziert_ab Änderungs- bzw. Einfügezeitpunkt, ab dem die Veranstaltungsterminreihen geliefert werden sollen. Das Format muss wie folgt sein: yyyy-MM-ddTHH:mm:ss.SSS (optional)
     * @param  bool $stornierte_veranstaltungsterminreihen_abrufen Optionaler Parameter, um zu steuern, ob stornierte oder nicht stornierte Veranstaltungsterminreihen abgerufen werden sollen. Der Default ist false. (optional)
     * @param  string $veranstaltungstyp_id Optionaler Parameter, um nur Veranstaltungsterminreihen eines bestimmten Veranstaltungstyps abzurufen. Beispiel-ID: cfa1403a-13c6-4681-8ee3-e30127554845 (optional)
     * @param  string $teilnehmergruppekuerzel Optionaler Parameter, um zu steuern, für welche Teilnehmergruppe die Veranstaltungsterminreihen abgerufen werden sollen. Ist eine Teilnehmergruppe angegeben, so werden alle in der Zukunft liegenden und publizierten Veranstaltungsterminreihen für diese Teilnehmergruppe zurückgegeben. (optional)
     * @param  string $veranstaltungskategorie_id Optionaler Parameter, um Veranstaltungsterminreihen nach einer Veranstaltungskategorie zu filtern. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVeranstaltungsterminreihenUsingGET1Async($modifiziert_ab = null, $stornierte_veranstaltungsterminreihen_abrufen = null, $veranstaltungstyp_id = null, $teilnehmergruppekuerzel = null, $veranstaltungskategorie_id = null)
    {
        return $this->getVeranstaltungsterminreihenUsingGET1AsyncWithHttpInfo($modifiziert_ab, $stornierte_veranstaltungsterminreihen_abrufen, $veranstaltungstyp_id, $teilnehmergruppekuerzel, $veranstaltungskategorie_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getVeranstaltungsterminreihenUsingGET1AsyncWithHttpInfo
     *
     * Ruft Veranstaltungsterminreihen ab (entweder nicht stornierte oder stornierte)
     *
     * @param  \DateTime $modifiziert_ab Änderungs- bzw. Einfügezeitpunkt, ab dem die Veranstaltungsterminreihen geliefert werden sollen. Das Format muss wie folgt sein: yyyy-MM-ddTHH:mm:ss.SSS (optional)
     * @param  bool $stornierte_veranstaltungsterminreihen_abrufen Optionaler Parameter, um zu steuern, ob stornierte oder nicht stornierte Veranstaltungsterminreihen abgerufen werden sollen. Der Default ist false. (optional)
     * @param  string $veranstaltungstyp_id Optionaler Parameter, um nur Veranstaltungsterminreihen eines bestimmten Veranstaltungstyps abzurufen. Beispiel-ID: cfa1403a-13c6-4681-8ee3-e30127554845 (optional)
     * @param  string $teilnehmergruppekuerzel Optionaler Parameter, um zu steuern, für welche Teilnehmergruppe die Veranstaltungsterminreihen abgerufen werden sollen. Ist eine Teilnehmergruppe angegeben, so werden alle in der Zukunft liegenden und publizierten Veranstaltungsterminreihen für diese Teilnehmergruppe zurückgegeben. (optional)
     * @param  string $veranstaltungskategorie_id Optionaler Parameter, um Veranstaltungsterminreihen nach einer Veranstaltungskategorie zu filtern. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVeranstaltungsterminreihenUsingGET1AsyncWithHttpInfo($modifiziert_ab = null, $stornierte_veranstaltungsterminreihen_abrufen = null, $veranstaltungstyp_id = null, $teilnehmergruppekuerzel = null, $veranstaltungskategorie_id = null)
    {
        $returnType = '\Swagger\Client\Model\Veranstaltungsterminreihe[]';
        $request = $this->getVeranstaltungsterminreihenUsingGET1Request($modifiziert_ab, $stornierte_veranstaltungsterminreihen_abrufen, $veranstaltungstyp_id, $teilnehmergruppekuerzel, $veranstaltungskategorie_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getVeranstaltungsterminreihenUsingGET1'
     *
     * @param  \DateTime $modifiziert_ab Änderungs- bzw. Einfügezeitpunkt, ab dem die Veranstaltungsterminreihen geliefert werden sollen. Das Format muss wie folgt sein: yyyy-MM-ddTHH:mm:ss.SSS (optional)
     * @param  bool $stornierte_veranstaltungsterminreihen_abrufen Optionaler Parameter, um zu steuern, ob stornierte oder nicht stornierte Veranstaltungsterminreihen abgerufen werden sollen. Der Default ist false. (optional)
     * @param  string $veranstaltungstyp_id Optionaler Parameter, um nur Veranstaltungsterminreihen eines bestimmten Veranstaltungstyps abzurufen. Beispiel-ID: cfa1403a-13c6-4681-8ee3-e30127554845 (optional)
     * @param  string $teilnehmergruppekuerzel Optionaler Parameter, um zu steuern, für welche Teilnehmergruppe die Veranstaltungsterminreihen abgerufen werden sollen. Ist eine Teilnehmergruppe angegeben, so werden alle in der Zukunft liegenden und publizierten Veranstaltungsterminreihen für diese Teilnehmergruppe zurückgegeben. (optional)
     * @param  string $veranstaltungskategorie_id Optionaler Parameter, um Veranstaltungsterminreihen nach einer Veranstaltungskategorie zu filtern. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getVeranstaltungsterminreihenUsingGET1Request($modifiziert_ab = null, $stornierte_veranstaltungsterminreihen_abrufen = null, $veranstaltungstyp_id = null, $teilnehmergruppekuerzel = null, $veranstaltungskategorie_id = null)
    {

        $resourcePath = '/v2/20010/veranstaltungsterminreihen';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($modifiziert_ab !== null) {
            $queryParams['modifiziertAb'] = ObjectSerializer::toQueryValue($modifiziert_ab);
        }
        // query params
        if ($stornierte_veranstaltungsterminreihen_abrufen !== null) {
            $queryParams['stornierteVeranstaltungsterminreihenAbrufen'] = ObjectSerializer::toQueryValue($stornierte_veranstaltungsterminreihen_abrufen);
        }
        // query params
        if ($veranstaltungstyp_id !== null) {
            $queryParams['veranstaltungstypID'] = ObjectSerializer::toQueryValue($veranstaltungstyp_id);
        }
        // query params
        if ($teilnehmergruppekuerzel !== null) {
            $queryParams['teilnehmergruppekuerzel'] = ObjectSerializer::toQueryValue($teilnehmergruppekuerzel);
        }
        // query params
        if ($veranstaltungskategorie_id !== null) {
            $queryParams['veranstaltungskategorieId'] = ObjectSerializer::toQueryValue($veranstaltungskategorie_id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
