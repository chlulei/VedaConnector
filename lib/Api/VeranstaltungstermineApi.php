<?php
/**
 * VeranstaltungstermineApi
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * VEDA Bildungsmanager API
 *
 * Dokumentation der REST-Schnittstellen des VEDA Bildungsmanagers für die Version 2. Die Dokumentation zu speziellen Versionen kann über die Angabe des zusätzlichen Parameters \"group\" angezeigt werden. Beispiel: .../api/docs?group=v1 für die Dokumentation der Version 1, die aktuelle Version ist unter .../api/docs erreichbar.
 *
 * OpenAPI spec version: 2
 * Contact: info@veda.net
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.21
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Swagger\Client\ApiException;
use Swagger\Client\Configuration;
use Swagger\Client\HeaderSelector;
use Swagger\Client\ObjectSerializer;

/**
 * VeranstaltungstermineApi Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class VeranstaltungstermineApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation createVeranstaltungsterminBuchungUsingPOST
     *
     * Ermöglicht es, einen Teilnehmer auf einen Veranstaltungstermin zu buchen.
     *
     * @param  string $termin_id ID des Veranstaltungstermins (required)
     * @param  \Swagger\Client\Model\TeilnehmerAktionBuchenApiDto $teilnehmerbuchung_create_api_dto Informationen zu einer Teilnehmerbuchung, die angelegt werden soll. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\TeilnehmerbuchungApiDto
     */
    public function createVeranstaltungsterminBuchungUsingPOST($termin_id, $teilnehmerbuchung_create_api_dto = null)
    {
        list($response) = $this->createVeranstaltungsterminBuchungUsingPOSTWithHttpInfo($termin_id, $teilnehmerbuchung_create_api_dto);
        return $response;
    }

    /**
     * Operation createVeranstaltungsterminBuchungUsingPOSTWithHttpInfo
     *
     * Ermöglicht es, einen Teilnehmer auf einen Veranstaltungstermin zu buchen.
     *
     * @param  string $termin_id ID des Veranstaltungstermins (required)
     * @param  \Swagger\Client\Model\TeilnehmerAktionBuchenApiDto $teilnehmerbuchung_create_api_dto Informationen zu einer Teilnehmerbuchung, die angelegt werden soll. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\TeilnehmerbuchungApiDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function createVeranstaltungsterminBuchungUsingPOSTWithHttpInfo($termin_id, $teilnehmerbuchung_create_api_dto = null)
    {
        $returnType = '\Swagger\Client\Model\TeilnehmerbuchungApiDto';
        $request = $this->createVeranstaltungsterminBuchungUsingPOSTRequest($termin_id, $teilnehmerbuchung_create_api_dto);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\TeilnehmerbuchungApiDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createVeranstaltungsterminBuchungUsingPOSTAsync
     *
     * Ermöglicht es, einen Teilnehmer auf einen Veranstaltungstermin zu buchen.
     *
     * @param  string $termin_id ID des Veranstaltungstermins (required)
     * @param  \Swagger\Client\Model\TeilnehmerAktionBuchenApiDto $teilnehmerbuchung_create_api_dto Informationen zu einer Teilnehmerbuchung, die angelegt werden soll. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createVeranstaltungsterminBuchungUsingPOSTAsync($termin_id, $teilnehmerbuchung_create_api_dto = null)
    {
        return $this->createVeranstaltungsterminBuchungUsingPOSTAsyncWithHttpInfo($termin_id, $teilnehmerbuchung_create_api_dto)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createVeranstaltungsterminBuchungUsingPOSTAsyncWithHttpInfo
     *
     * Ermöglicht es, einen Teilnehmer auf einen Veranstaltungstermin zu buchen.
     *
     * @param  string $termin_id ID des Veranstaltungstermins (required)
     * @param  \Swagger\Client\Model\TeilnehmerAktionBuchenApiDto $teilnehmerbuchung_create_api_dto Informationen zu einer Teilnehmerbuchung, die angelegt werden soll. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createVeranstaltungsterminBuchungUsingPOSTAsyncWithHttpInfo($termin_id, $teilnehmerbuchung_create_api_dto = null)
    {
        $returnType = '\Swagger\Client\Model\TeilnehmerbuchungApiDto';
        $request = $this->createVeranstaltungsterminBuchungUsingPOSTRequest($termin_id, $teilnehmerbuchung_create_api_dto);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createVeranstaltungsterminBuchungUsingPOST'
     *
     * @param  string $termin_id ID des Veranstaltungstermins (required)
     * @param  \Swagger\Client\Model\TeilnehmerAktionBuchenApiDto $teilnehmerbuchung_create_api_dto Informationen zu einer Teilnehmerbuchung, die angelegt werden soll. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createVeranstaltungsterminBuchungUsingPOSTRequest($termin_id, $teilnehmerbuchung_create_api_dto = null)
    {
        // verify the required parameter 'termin_id' is set
        if ($termin_id === null || (is_array($termin_id) && count($termin_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $termin_id when calling createVeranstaltungsterminBuchungUsingPOST'
            );
        }

        $resourcePath = '/v2/veranstaltungstermine/{terminId}/buchen';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($termin_id !== null) {
            $resourcePath = str_replace(
                '{' . 'terminId' . '}',
                ObjectSerializer::toPathValue($termin_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($teilnehmerbuchung_create_api_dto)) {
            $_tempBody = $teilnehmerbuchung_create_api_dto;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createVeranstaltungsterminBuchungUsingPOST1
     *
     * Ermöglicht es, einen Teilnehmer auf einen Veranstaltungstermin zu buchen.
     *
     * @param  string $termin_id ID des Veranstaltungstermins (required)
     * @param  \Swagger\Client\Model\TeilnehmerAktionBuchenApiDto $teilnehmerbuchung_create_api_dto Informationen zu einer Teilnehmerbuchung, die angelegt werden soll. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\TeilnehmerbuchungApiDto
     */
    public function createVeranstaltungsterminBuchungUsingPOST1($termin_id, $teilnehmerbuchung_create_api_dto = null)
    {
        list($response) = $this->createVeranstaltungsterminBuchungUsingPOST1WithHttpInfo($termin_id, $teilnehmerbuchung_create_api_dto);
        return $response;
    }

    /**
     * Operation createVeranstaltungsterminBuchungUsingPOST1WithHttpInfo
     *
     * Ermöglicht es, einen Teilnehmer auf einen Veranstaltungstermin zu buchen.
     *
     * @param  string $termin_id ID des Veranstaltungstermins (required)
     * @param  \Swagger\Client\Model\TeilnehmerAktionBuchenApiDto $teilnehmerbuchung_create_api_dto Informationen zu einer Teilnehmerbuchung, die angelegt werden soll. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\TeilnehmerbuchungApiDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function createVeranstaltungsterminBuchungUsingPOST1WithHttpInfo($termin_id, $teilnehmerbuchung_create_api_dto = null)
    {
        $returnType = '\Swagger\Client\Model\TeilnehmerbuchungApiDto';
        $request = $this->createVeranstaltungsterminBuchungUsingPOST1Request($termin_id, $teilnehmerbuchung_create_api_dto);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\TeilnehmerbuchungApiDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createVeranstaltungsterminBuchungUsingPOST1Async
     *
     * Ermöglicht es, einen Teilnehmer auf einen Veranstaltungstermin zu buchen.
     *
     * @param  string $termin_id ID des Veranstaltungstermins (required)
     * @param  \Swagger\Client\Model\TeilnehmerAktionBuchenApiDto $teilnehmerbuchung_create_api_dto Informationen zu einer Teilnehmerbuchung, die angelegt werden soll. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createVeranstaltungsterminBuchungUsingPOST1Async($termin_id, $teilnehmerbuchung_create_api_dto = null)
    {
        return $this->createVeranstaltungsterminBuchungUsingPOST1AsyncWithHttpInfo($termin_id, $teilnehmerbuchung_create_api_dto)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createVeranstaltungsterminBuchungUsingPOST1AsyncWithHttpInfo
     *
     * Ermöglicht es, einen Teilnehmer auf einen Veranstaltungstermin zu buchen.
     *
     * @param  string $termin_id ID des Veranstaltungstermins (required)
     * @param  \Swagger\Client\Model\TeilnehmerAktionBuchenApiDto $teilnehmerbuchung_create_api_dto Informationen zu einer Teilnehmerbuchung, die angelegt werden soll. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createVeranstaltungsterminBuchungUsingPOST1AsyncWithHttpInfo($termin_id, $teilnehmerbuchung_create_api_dto = null)
    {
        $returnType = '\Swagger\Client\Model\TeilnehmerbuchungApiDto';
        $request = $this->createVeranstaltungsterminBuchungUsingPOST1Request($termin_id, $teilnehmerbuchung_create_api_dto);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createVeranstaltungsterminBuchungUsingPOST1'
     *
     * @param  string $termin_id ID des Veranstaltungstermins (required)
     * @param  \Swagger\Client\Model\TeilnehmerAktionBuchenApiDto $teilnehmerbuchung_create_api_dto Informationen zu einer Teilnehmerbuchung, die angelegt werden soll. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createVeranstaltungsterminBuchungUsingPOST1Request($termin_id, $teilnehmerbuchung_create_api_dto = null)
    {
        // verify the required parameter 'termin_id' is set
        if ($termin_id === null || (is_array($termin_id) && count($termin_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $termin_id when calling createVeranstaltungsterminBuchungUsingPOST1'
            );
        }

        $resourcePath = '/v2/20010/veranstaltungstermine/{terminId}/buchen';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($termin_id !== null) {
            $resourcePath = str_replace(
                '{' . 'terminId' . '}',
                ObjectSerializer::toPathValue($termin_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($teilnehmerbuchung_create_api_dto)) {
            $_tempBody = $teilnehmerbuchung_create_api_dto;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTeilnehmerbuchungenZuVeranstaltungsterminUsingGET
     *
     * Ermöglicht es, Teilnehmerbuchungen die den Status \"Angemeldet\", \"Eingeladen\" oder \"Bestätigt\" gesetzt haben für einen Veranstaltungstermin abzurufen.
     *
     * @param  string $id ID des Veranstaltungstermins, zu dem die Teilnehmerbuchungen geladen werden sollen (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\TeilnehmerbuchungAbrufenApiDto[]
     */
    public function getTeilnehmerbuchungenZuVeranstaltungsterminUsingGET($id)
    {
        list($response) = $this->getTeilnehmerbuchungenZuVeranstaltungsterminUsingGETWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getTeilnehmerbuchungenZuVeranstaltungsterminUsingGETWithHttpInfo
     *
     * Ermöglicht es, Teilnehmerbuchungen die den Status \"Angemeldet\", \"Eingeladen\" oder \"Bestätigt\" gesetzt haben für einen Veranstaltungstermin abzurufen.
     *
     * @param  string $id ID des Veranstaltungstermins, zu dem die Teilnehmerbuchungen geladen werden sollen (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\TeilnehmerbuchungAbrufenApiDto[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getTeilnehmerbuchungenZuVeranstaltungsterminUsingGETWithHttpInfo($id)
    {
        $returnType = '\Swagger\Client\Model\TeilnehmerbuchungAbrufenApiDto[]';
        $request = $this->getTeilnehmerbuchungenZuVeranstaltungsterminUsingGETRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\TeilnehmerbuchungAbrufenApiDto[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTeilnehmerbuchungenZuVeranstaltungsterminUsingGETAsync
     *
     * Ermöglicht es, Teilnehmerbuchungen die den Status \"Angemeldet\", \"Eingeladen\" oder \"Bestätigt\" gesetzt haben für einen Veranstaltungstermin abzurufen.
     *
     * @param  string $id ID des Veranstaltungstermins, zu dem die Teilnehmerbuchungen geladen werden sollen (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTeilnehmerbuchungenZuVeranstaltungsterminUsingGETAsync($id)
    {
        return $this->getTeilnehmerbuchungenZuVeranstaltungsterminUsingGETAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTeilnehmerbuchungenZuVeranstaltungsterminUsingGETAsyncWithHttpInfo
     *
     * Ermöglicht es, Teilnehmerbuchungen die den Status \"Angemeldet\", \"Eingeladen\" oder \"Bestätigt\" gesetzt haben für einen Veranstaltungstermin abzurufen.
     *
     * @param  string $id ID des Veranstaltungstermins, zu dem die Teilnehmerbuchungen geladen werden sollen (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTeilnehmerbuchungenZuVeranstaltungsterminUsingGETAsyncWithHttpInfo($id)
    {
        $returnType = '\Swagger\Client\Model\TeilnehmerbuchungAbrufenApiDto[]';
        $request = $this->getTeilnehmerbuchungenZuVeranstaltungsterminUsingGETRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTeilnehmerbuchungenZuVeranstaltungsterminUsingGET'
     *
     * @param  string $id ID des Veranstaltungstermins, zu dem die Teilnehmerbuchungen geladen werden sollen (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTeilnehmerbuchungenZuVeranstaltungsterminUsingGETRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getTeilnehmerbuchungenZuVeranstaltungsterminUsingGET'
            );
        }

        $resourcePath = '/v2/veranstaltungstermine/{id}/teilnehmerbuchungen';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTeilnehmerbuchungenZuVeranstaltungsterminUsingGET1
     *
     * Ermöglicht es, Teilnehmerbuchungen die den Status \"Angemeldet\", \"Eingeladen\" oder \"Bestätigt\" gesetzt haben für einen Veranstaltungstermin abzurufen.
     *
     * @param  string $id ID des Veranstaltungstermins, zu dem die Teilnehmerbuchungen geladen werden sollen (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\TeilnehmerbuchungAbrufenApiDto[]
     */
    public function getTeilnehmerbuchungenZuVeranstaltungsterminUsingGET1($id)
    {
        list($response) = $this->getTeilnehmerbuchungenZuVeranstaltungsterminUsingGET1WithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getTeilnehmerbuchungenZuVeranstaltungsterminUsingGET1WithHttpInfo
     *
     * Ermöglicht es, Teilnehmerbuchungen die den Status \"Angemeldet\", \"Eingeladen\" oder \"Bestätigt\" gesetzt haben für einen Veranstaltungstermin abzurufen.
     *
     * @param  string $id ID des Veranstaltungstermins, zu dem die Teilnehmerbuchungen geladen werden sollen (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\TeilnehmerbuchungAbrufenApiDto[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getTeilnehmerbuchungenZuVeranstaltungsterminUsingGET1WithHttpInfo($id)
    {
        $returnType = '\Swagger\Client\Model\TeilnehmerbuchungAbrufenApiDto[]';
        $request = $this->getTeilnehmerbuchungenZuVeranstaltungsterminUsingGET1Request($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\TeilnehmerbuchungAbrufenApiDto[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTeilnehmerbuchungenZuVeranstaltungsterminUsingGET1Async
     *
     * Ermöglicht es, Teilnehmerbuchungen die den Status \"Angemeldet\", \"Eingeladen\" oder \"Bestätigt\" gesetzt haben für einen Veranstaltungstermin abzurufen.
     *
     * @param  string $id ID des Veranstaltungstermins, zu dem die Teilnehmerbuchungen geladen werden sollen (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTeilnehmerbuchungenZuVeranstaltungsterminUsingGET1Async($id)
    {
        return $this->getTeilnehmerbuchungenZuVeranstaltungsterminUsingGET1AsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTeilnehmerbuchungenZuVeranstaltungsterminUsingGET1AsyncWithHttpInfo
     *
     * Ermöglicht es, Teilnehmerbuchungen die den Status \"Angemeldet\", \"Eingeladen\" oder \"Bestätigt\" gesetzt haben für einen Veranstaltungstermin abzurufen.
     *
     * @param  string $id ID des Veranstaltungstermins, zu dem die Teilnehmerbuchungen geladen werden sollen (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTeilnehmerbuchungenZuVeranstaltungsterminUsingGET1AsyncWithHttpInfo($id)
    {
        $returnType = '\Swagger\Client\Model\TeilnehmerbuchungAbrufenApiDto[]';
        $request = $this->getTeilnehmerbuchungenZuVeranstaltungsterminUsingGET1Request($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTeilnehmerbuchungenZuVeranstaltungsterminUsingGET1'
     *
     * @param  string $id ID des Veranstaltungstermins, zu dem die Teilnehmerbuchungen geladen werden sollen (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTeilnehmerbuchungenZuVeranstaltungsterminUsingGET1Request($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getTeilnehmerbuchungenZuVeranstaltungsterminUsingGET1'
            );
        }

        $resourcePath = '/v2/20010/veranstaltungstermine/{id}/teilnehmerbuchungen';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getVeranstaltungsterminUsingGET
     *
     * Ruft einen Veranstaltungstermin ab (entweder nicht storniert oder storniert)
     *
     * @param  string $id ID des Veranstaltungstermins (required)
     * @param  bool $stornierten_termin_abrufen Optionaler Parameter, um zu steuern, ob ein stornierter oder ein nicht stornierter Veranstaltungstermin abgerufen werden soll. Der Default ist false. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Veranstaltungstermin
     */
    public function getVeranstaltungsterminUsingGET($id, $stornierten_termin_abrufen = null)
    {
        list($response) = $this->getVeranstaltungsterminUsingGETWithHttpInfo($id, $stornierten_termin_abrufen);
        return $response;
    }

    /**
     * Operation getVeranstaltungsterminUsingGETWithHttpInfo
     *
     * Ruft einen Veranstaltungstermin ab (entweder nicht storniert oder storniert)
     *
     * @param  string $id ID des Veranstaltungstermins (required)
     * @param  bool $stornierten_termin_abrufen Optionaler Parameter, um zu steuern, ob ein stornierter oder ein nicht stornierter Veranstaltungstermin abgerufen werden soll. Der Default ist false. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Veranstaltungstermin, HTTP status code, HTTP response headers (array of strings)
     */
    public function getVeranstaltungsterminUsingGETWithHttpInfo($id, $stornierten_termin_abrufen = null)
    {
        $returnType = '\Swagger\Client\Model\Veranstaltungstermin';
        $request = $this->getVeranstaltungsterminUsingGETRequest($id, $stornierten_termin_abrufen);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Veranstaltungstermin',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getVeranstaltungsterminUsingGETAsync
     *
     * Ruft einen Veranstaltungstermin ab (entweder nicht storniert oder storniert)
     *
     * @param  string $id ID des Veranstaltungstermins (required)
     * @param  bool $stornierten_termin_abrufen Optionaler Parameter, um zu steuern, ob ein stornierter oder ein nicht stornierter Veranstaltungstermin abgerufen werden soll. Der Default ist false. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVeranstaltungsterminUsingGETAsync($id, $stornierten_termin_abrufen = null)
    {
        return $this->getVeranstaltungsterminUsingGETAsyncWithHttpInfo($id, $stornierten_termin_abrufen)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getVeranstaltungsterminUsingGETAsyncWithHttpInfo
     *
     * Ruft einen Veranstaltungstermin ab (entweder nicht storniert oder storniert)
     *
     * @param  string $id ID des Veranstaltungstermins (required)
     * @param  bool $stornierten_termin_abrufen Optionaler Parameter, um zu steuern, ob ein stornierter oder ein nicht stornierter Veranstaltungstermin abgerufen werden soll. Der Default ist false. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVeranstaltungsterminUsingGETAsyncWithHttpInfo($id, $stornierten_termin_abrufen = null)
    {
        $returnType = '\Swagger\Client\Model\Veranstaltungstermin';
        $request = $this->getVeranstaltungsterminUsingGETRequest($id, $stornierten_termin_abrufen);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getVeranstaltungsterminUsingGET'
     *
     * @param  string $id ID des Veranstaltungstermins (required)
     * @param  bool $stornierten_termin_abrufen Optionaler Parameter, um zu steuern, ob ein stornierter oder ein nicht stornierter Veranstaltungstermin abgerufen werden soll. Der Default ist false. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getVeranstaltungsterminUsingGETRequest($id, $stornierten_termin_abrufen = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getVeranstaltungsterminUsingGET'
            );
        }

        $resourcePath = '/v2/veranstaltungstermine/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($stornierten_termin_abrufen !== null) {
            $queryParams['storniertenTerminAbrufen'] = ObjectSerializer::toQueryValue($stornierten_termin_abrufen);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getVeranstaltungsterminUsingGET1
     *
     * Ruft einen Veranstaltungstermin ab (entweder nicht storniert oder storniert)
     *
     * @param  string $id ID des Veranstaltungstermins (required)
     * @param  bool $stornierten_termin_abrufen Optionaler Parameter, um zu steuern, ob ein stornierter oder ein nicht stornierter Veranstaltungstermin abgerufen werden soll. Der Default ist false. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Veranstaltungstermin
     */
    public function getVeranstaltungsterminUsingGET1($id, $stornierten_termin_abrufen = null)
    {
        list($response) = $this->getVeranstaltungsterminUsingGET1WithHttpInfo($id, $stornierten_termin_abrufen);
        return $response;
    }

    /**
     * Operation getVeranstaltungsterminUsingGET1WithHttpInfo
     *
     * Ruft einen Veranstaltungstermin ab (entweder nicht storniert oder storniert)
     *
     * @param  string $id ID des Veranstaltungstermins (required)
     * @param  bool $stornierten_termin_abrufen Optionaler Parameter, um zu steuern, ob ein stornierter oder ein nicht stornierter Veranstaltungstermin abgerufen werden soll. Der Default ist false. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Veranstaltungstermin, HTTP status code, HTTP response headers (array of strings)
     */
    public function getVeranstaltungsterminUsingGET1WithHttpInfo($id, $stornierten_termin_abrufen = null)
    {
        $returnType = '\Swagger\Client\Model\Veranstaltungstermin';
        $request = $this->getVeranstaltungsterminUsingGET1Request($id, $stornierten_termin_abrufen);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Veranstaltungstermin',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getVeranstaltungsterminUsingGET1Async
     *
     * Ruft einen Veranstaltungstermin ab (entweder nicht storniert oder storniert)
     *
     * @param  string $id ID des Veranstaltungstermins (required)
     * @param  bool $stornierten_termin_abrufen Optionaler Parameter, um zu steuern, ob ein stornierter oder ein nicht stornierter Veranstaltungstermin abgerufen werden soll. Der Default ist false. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVeranstaltungsterminUsingGET1Async($id, $stornierten_termin_abrufen = null)
    {
        return $this->getVeranstaltungsterminUsingGET1AsyncWithHttpInfo($id, $stornierten_termin_abrufen)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getVeranstaltungsterminUsingGET1AsyncWithHttpInfo
     *
     * Ruft einen Veranstaltungstermin ab (entweder nicht storniert oder storniert)
     *
     * @param  string $id ID des Veranstaltungstermins (required)
     * @param  bool $stornierten_termin_abrufen Optionaler Parameter, um zu steuern, ob ein stornierter oder ein nicht stornierter Veranstaltungstermin abgerufen werden soll. Der Default ist false. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVeranstaltungsterminUsingGET1AsyncWithHttpInfo($id, $stornierten_termin_abrufen = null)
    {
        $returnType = '\Swagger\Client\Model\Veranstaltungstermin';
        $request = $this->getVeranstaltungsterminUsingGET1Request($id, $stornierten_termin_abrufen);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getVeranstaltungsterminUsingGET1'
     *
     * @param  string $id ID des Veranstaltungstermins (required)
     * @param  bool $stornierten_termin_abrufen Optionaler Parameter, um zu steuern, ob ein stornierter oder ein nicht stornierter Veranstaltungstermin abgerufen werden soll. Der Default ist false. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getVeranstaltungsterminUsingGET1Request($id, $stornierten_termin_abrufen = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getVeranstaltungsterminUsingGET1'
            );
        }

        $resourcePath = '/v2/20010/veranstaltungstermine/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($stornierten_termin_abrufen !== null) {
            $queryParams['storniertenTerminAbrufen'] = ObjectSerializer::toQueryValue($stornierten_termin_abrufen);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getVeranstaltungstermineUsingGET
     *
     * Ruft Veranstaltungstermine ab (entweder nicht stornierte oder stornierte)
     *
     * @param  \DateTime $modifiziert_ab Änderungs- bzw. Einfügezeitpunkt, ab dem die Veranstaltungstermine geliefert werden sollen. Das Format muss wie folgt sein: yyyy-MM-ddTHH:mm:ss.SSS (optional)
     * @param  bool $stornierte_termine_abrufen Optionaler Parameter, um zu steuern, ob stornierte oder nicht stornierte Veranstaltungstermine abgerufen werden sollen. Der Default ist false. (optional)
     * @param  string $veranstaltungstyp_id Optionaler Parameter, um nur Veranstaltungstermine eines bestimmten Veranstaltungstyps abzurufen. Beispiel-ID: cfa1403a-13c6-4681-8ee3-e30127554845 (optional)
     * @param  string $teilnehmergruppekuerzel Optionaler Parameter, um zu steuern, für welche Teilnehmergruppe die Veranstaltungstermine abgerufen werden sollen. Ist eine Teilnehmergruppe angegeben, so werden alle in der Zukunft liegenden und publizierten Veranstaltungen für diese Teilnehmergruppe zurückgegeben. (optional)
     * @param  string $veranstaltungskategorie_id Optionaler Parameter, um Veranstaltungstermine nach einer Veranstaltungskategorie zu filtern. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Veranstaltungstermin[]
     */
    public function getVeranstaltungstermineUsingGET($modifiziert_ab = null, $stornierte_termine_abrufen = null, $veranstaltungstyp_id = null, $teilnehmergruppekuerzel = null, $veranstaltungskategorie_id = null)
    {
        list($response) = $this->getVeranstaltungstermineUsingGETWithHttpInfo($modifiziert_ab, $stornierte_termine_abrufen, $veranstaltungstyp_id, $teilnehmergruppekuerzel, $veranstaltungskategorie_id);
        return $response;
    }

    /**
     * Operation getVeranstaltungstermineUsingGETWithHttpInfo
     *
     * Ruft Veranstaltungstermine ab (entweder nicht stornierte oder stornierte)
     *
     * @param  \DateTime $modifiziert_ab Änderungs- bzw. Einfügezeitpunkt, ab dem die Veranstaltungstermine geliefert werden sollen. Das Format muss wie folgt sein: yyyy-MM-ddTHH:mm:ss.SSS (optional)
     * @param  bool $stornierte_termine_abrufen Optionaler Parameter, um zu steuern, ob stornierte oder nicht stornierte Veranstaltungstermine abgerufen werden sollen. Der Default ist false. (optional)
     * @param  string $veranstaltungstyp_id Optionaler Parameter, um nur Veranstaltungstermine eines bestimmten Veranstaltungstyps abzurufen. Beispiel-ID: cfa1403a-13c6-4681-8ee3-e30127554845 (optional)
     * @param  string $teilnehmergruppekuerzel Optionaler Parameter, um zu steuern, für welche Teilnehmergruppe die Veranstaltungstermine abgerufen werden sollen. Ist eine Teilnehmergruppe angegeben, so werden alle in der Zukunft liegenden und publizierten Veranstaltungen für diese Teilnehmergruppe zurückgegeben. (optional)
     * @param  string $veranstaltungskategorie_id Optionaler Parameter, um Veranstaltungstermine nach einer Veranstaltungskategorie zu filtern. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Veranstaltungstermin[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getVeranstaltungstermineUsingGETWithHttpInfo($modifiziert_ab = null, $stornierte_termine_abrufen = null, $veranstaltungstyp_id = null, $teilnehmergruppekuerzel = null, $veranstaltungskategorie_id = null)
    {
        $returnType = '\Swagger\Client\Model\Veranstaltungstermin[]';
        $request = $this->getVeranstaltungstermineUsingGETRequest($modifiziert_ab, $stornierte_termine_abrufen, $veranstaltungstyp_id, $teilnehmergruppekuerzel, $veranstaltungskategorie_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Veranstaltungstermin[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getVeranstaltungstermineUsingGETAsync
     *
     * Ruft Veranstaltungstermine ab (entweder nicht stornierte oder stornierte)
     *
     * @param  \DateTime $modifiziert_ab Änderungs- bzw. Einfügezeitpunkt, ab dem die Veranstaltungstermine geliefert werden sollen. Das Format muss wie folgt sein: yyyy-MM-ddTHH:mm:ss.SSS (optional)
     * @param  bool $stornierte_termine_abrufen Optionaler Parameter, um zu steuern, ob stornierte oder nicht stornierte Veranstaltungstermine abgerufen werden sollen. Der Default ist false. (optional)
     * @param  string $veranstaltungstyp_id Optionaler Parameter, um nur Veranstaltungstermine eines bestimmten Veranstaltungstyps abzurufen. Beispiel-ID: cfa1403a-13c6-4681-8ee3-e30127554845 (optional)
     * @param  string $teilnehmergruppekuerzel Optionaler Parameter, um zu steuern, für welche Teilnehmergruppe die Veranstaltungstermine abgerufen werden sollen. Ist eine Teilnehmergruppe angegeben, so werden alle in der Zukunft liegenden und publizierten Veranstaltungen für diese Teilnehmergruppe zurückgegeben. (optional)
     * @param  string $veranstaltungskategorie_id Optionaler Parameter, um Veranstaltungstermine nach einer Veranstaltungskategorie zu filtern. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVeranstaltungstermineUsingGETAsync($modifiziert_ab = null, $stornierte_termine_abrufen = null, $veranstaltungstyp_id = null, $teilnehmergruppekuerzel = null, $veranstaltungskategorie_id = null)
    {
        return $this->getVeranstaltungstermineUsingGETAsyncWithHttpInfo($modifiziert_ab, $stornierte_termine_abrufen, $veranstaltungstyp_id, $teilnehmergruppekuerzel, $veranstaltungskategorie_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getVeranstaltungstermineUsingGETAsyncWithHttpInfo
     *
     * Ruft Veranstaltungstermine ab (entweder nicht stornierte oder stornierte)
     *
     * @param  \DateTime $modifiziert_ab Änderungs- bzw. Einfügezeitpunkt, ab dem die Veranstaltungstermine geliefert werden sollen. Das Format muss wie folgt sein: yyyy-MM-ddTHH:mm:ss.SSS (optional)
     * @param  bool $stornierte_termine_abrufen Optionaler Parameter, um zu steuern, ob stornierte oder nicht stornierte Veranstaltungstermine abgerufen werden sollen. Der Default ist false. (optional)
     * @param  string $veranstaltungstyp_id Optionaler Parameter, um nur Veranstaltungstermine eines bestimmten Veranstaltungstyps abzurufen. Beispiel-ID: cfa1403a-13c6-4681-8ee3-e30127554845 (optional)
     * @param  string $teilnehmergruppekuerzel Optionaler Parameter, um zu steuern, für welche Teilnehmergruppe die Veranstaltungstermine abgerufen werden sollen. Ist eine Teilnehmergruppe angegeben, so werden alle in der Zukunft liegenden und publizierten Veranstaltungen für diese Teilnehmergruppe zurückgegeben. (optional)
     * @param  string $veranstaltungskategorie_id Optionaler Parameter, um Veranstaltungstermine nach einer Veranstaltungskategorie zu filtern. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVeranstaltungstermineUsingGETAsyncWithHttpInfo($modifiziert_ab = null, $stornierte_termine_abrufen = null, $veranstaltungstyp_id = null, $teilnehmergruppekuerzel = null, $veranstaltungskategorie_id = null)
    {
        $returnType = '\Swagger\Client\Model\Veranstaltungstermin[]';
        $request = $this->getVeranstaltungstermineUsingGETRequest($modifiziert_ab, $stornierte_termine_abrufen, $veranstaltungstyp_id, $teilnehmergruppekuerzel, $veranstaltungskategorie_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getVeranstaltungstermineUsingGET'
     *
     * @param  \DateTime $modifiziert_ab Änderungs- bzw. Einfügezeitpunkt, ab dem die Veranstaltungstermine geliefert werden sollen. Das Format muss wie folgt sein: yyyy-MM-ddTHH:mm:ss.SSS (optional)
     * @param  bool $stornierte_termine_abrufen Optionaler Parameter, um zu steuern, ob stornierte oder nicht stornierte Veranstaltungstermine abgerufen werden sollen. Der Default ist false. (optional)
     * @param  string $veranstaltungstyp_id Optionaler Parameter, um nur Veranstaltungstermine eines bestimmten Veranstaltungstyps abzurufen. Beispiel-ID: cfa1403a-13c6-4681-8ee3-e30127554845 (optional)
     * @param  string $teilnehmergruppekuerzel Optionaler Parameter, um zu steuern, für welche Teilnehmergruppe die Veranstaltungstermine abgerufen werden sollen. Ist eine Teilnehmergruppe angegeben, so werden alle in der Zukunft liegenden und publizierten Veranstaltungen für diese Teilnehmergruppe zurückgegeben. (optional)
     * @param  string $veranstaltungskategorie_id Optionaler Parameter, um Veranstaltungstermine nach einer Veranstaltungskategorie zu filtern. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getVeranstaltungstermineUsingGETRequest($modifiziert_ab = null, $stornierte_termine_abrufen = null, $veranstaltungstyp_id = null, $teilnehmergruppekuerzel = null, $veranstaltungskategorie_id = null)
    {

        $resourcePath = '/v2/veranstaltungstermine';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($modifiziert_ab !== null) {
            $queryParams['modifiziertAb'] = ObjectSerializer::toQueryValue($modifiziert_ab);
        }
        // query params
        if ($stornierte_termine_abrufen !== null) {
            $queryParams['stornierteTermineAbrufen'] = ObjectSerializer::toQueryValue($stornierte_termine_abrufen);
        }
        // query params
        if ($veranstaltungstyp_id !== null) {
            $queryParams['veranstaltungstypID'] = ObjectSerializer::toQueryValue($veranstaltungstyp_id);
        }
        // query params
        if ($teilnehmergruppekuerzel !== null) {
            $queryParams['teilnehmergruppekuerzel'] = ObjectSerializer::toQueryValue($teilnehmergruppekuerzel);
        }
        // query params
        if ($veranstaltungskategorie_id !== null) {
            $queryParams['veranstaltungskategorieId'] = ObjectSerializer::toQueryValue($veranstaltungskategorie_id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getVeranstaltungstermineUsingGET1
     *
     * Ruft Veranstaltungstermine ab (entweder nicht stornierte oder stornierte)
     *
     * @param  \DateTime $modifiziert_ab Änderungs- bzw. Einfügezeitpunkt, ab dem die Veranstaltungstermine geliefert werden sollen. Das Format muss wie folgt sein: yyyy-MM-ddTHH:mm:ss.SSS (optional)
     * @param  bool $stornierte_termine_abrufen Optionaler Parameter, um zu steuern, ob stornierte oder nicht stornierte Veranstaltungstermine abgerufen werden sollen. Der Default ist false. (optional)
     * @param  string $veranstaltungstyp_id Optionaler Parameter, um nur Veranstaltungstermine eines bestimmten Veranstaltungstyps abzurufen. Beispiel-ID: cfa1403a-13c6-4681-8ee3-e30127554845 (optional)
     * @param  string $teilnehmergruppekuerzel Optionaler Parameter, um zu steuern, für welche Teilnehmergruppe die Veranstaltungstermine abgerufen werden sollen. Ist eine Teilnehmergruppe angegeben, so werden alle in der Zukunft liegenden und publizierten Veranstaltungen für diese Teilnehmergruppe zurückgegeben. (optional)
     * @param  string $veranstaltungskategorie_id Optionaler Parameter, um Veranstaltungstermine nach einer Veranstaltungskategorie zu filtern. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Veranstaltungstermin[]
     */
    public function getVeranstaltungstermineUsingGET1($modifiziert_ab = null, $stornierte_termine_abrufen = null, $veranstaltungstyp_id = null, $teilnehmergruppekuerzel = null, $veranstaltungskategorie_id = null)
    {
        list($response) = $this->getVeranstaltungstermineUsingGET1WithHttpInfo($modifiziert_ab, $stornierte_termine_abrufen, $veranstaltungstyp_id, $teilnehmergruppekuerzel, $veranstaltungskategorie_id);
        return $response;
    }

    /**
     * Operation getVeranstaltungstermineUsingGET1WithHttpInfo
     *
     * Ruft Veranstaltungstermine ab (entweder nicht stornierte oder stornierte)
     *
     * @param  \DateTime $modifiziert_ab Änderungs- bzw. Einfügezeitpunkt, ab dem die Veranstaltungstermine geliefert werden sollen. Das Format muss wie folgt sein: yyyy-MM-ddTHH:mm:ss.SSS (optional)
     * @param  bool $stornierte_termine_abrufen Optionaler Parameter, um zu steuern, ob stornierte oder nicht stornierte Veranstaltungstermine abgerufen werden sollen. Der Default ist false. (optional)
     * @param  string $veranstaltungstyp_id Optionaler Parameter, um nur Veranstaltungstermine eines bestimmten Veranstaltungstyps abzurufen. Beispiel-ID: cfa1403a-13c6-4681-8ee3-e30127554845 (optional)
     * @param  string $teilnehmergruppekuerzel Optionaler Parameter, um zu steuern, für welche Teilnehmergruppe die Veranstaltungstermine abgerufen werden sollen. Ist eine Teilnehmergruppe angegeben, so werden alle in der Zukunft liegenden und publizierten Veranstaltungen für diese Teilnehmergruppe zurückgegeben. (optional)
     * @param  string $veranstaltungskategorie_id Optionaler Parameter, um Veranstaltungstermine nach einer Veranstaltungskategorie zu filtern. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Veranstaltungstermin[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getVeranstaltungstermineUsingGET1WithHttpInfo($modifiziert_ab = null, $stornierte_termine_abrufen = null, $veranstaltungstyp_id = null, $teilnehmergruppekuerzel = null, $veranstaltungskategorie_id = null)
    {
        $returnType = '\Swagger\Client\Model\Veranstaltungstermin[]';
        $request = $this->getVeranstaltungstermineUsingGET1Request($modifiziert_ab, $stornierte_termine_abrufen, $veranstaltungstyp_id, $teilnehmergruppekuerzel, $veranstaltungskategorie_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Veranstaltungstermin[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getVeranstaltungstermineUsingGET1Async
     *
     * Ruft Veranstaltungstermine ab (entweder nicht stornierte oder stornierte)
     *
     * @param  \DateTime $modifiziert_ab Änderungs- bzw. Einfügezeitpunkt, ab dem die Veranstaltungstermine geliefert werden sollen. Das Format muss wie folgt sein: yyyy-MM-ddTHH:mm:ss.SSS (optional)
     * @param  bool $stornierte_termine_abrufen Optionaler Parameter, um zu steuern, ob stornierte oder nicht stornierte Veranstaltungstermine abgerufen werden sollen. Der Default ist false. (optional)
     * @param  string $veranstaltungstyp_id Optionaler Parameter, um nur Veranstaltungstermine eines bestimmten Veranstaltungstyps abzurufen. Beispiel-ID: cfa1403a-13c6-4681-8ee3-e30127554845 (optional)
     * @param  string $teilnehmergruppekuerzel Optionaler Parameter, um zu steuern, für welche Teilnehmergruppe die Veranstaltungstermine abgerufen werden sollen. Ist eine Teilnehmergruppe angegeben, so werden alle in der Zukunft liegenden und publizierten Veranstaltungen für diese Teilnehmergruppe zurückgegeben. (optional)
     * @param  string $veranstaltungskategorie_id Optionaler Parameter, um Veranstaltungstermine nach einer Veranstaltungskategorie zu filtern. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVeranstaltungstermineUsingGET1Async($modifiziert_ab = null, $stornierte_termine_abrufen = null, $veranstaltungstyp_id = null, $teilnehmergruppekuerzel = null, $veranstaltungskategorie_id = null)
    {
        return $this->getVeranstaltungstermineUsingGET1AsyncWithHttpInfo($modifiziert_ab, $stornierte_termine_abrufen, $veranstaltungstyp_id, $teilnehmergruppekuerzel, $veranstaltungskategorie_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getVeranstaltungstermineUsingGET1AsyncWithHttpInfo
     *
     * Ruft Veranstaltungstermine ab (entweder nicht stornierte oder stornierte)
     *
     * @param  \DateTime $modifiziert_ab Änderungs- bzw. Einfügezeitpunkt, ab dem die Veranstaltungstermine geliefert werden sollen. Das Format muss wie folgt sein: yyyy-MM-ddTHH:mm:ss.SSS (optional)
     * @param  bool $stornierte_termine_abrufen Optionaler Parameter, um zu steuern, ob stornierte oder nicht stornierte Veranstaltungstermine abgerufen werden sollen. Der Default ist false. (optional)
     * @param  string $veranstaltungstyp_id Optionaler Parameter, um nur Veranstaltungstermine eines bestimmten Veranstaltungstyps abzurufen. Beispiel-ID: cfa1403a-13c6-4681-8ee3-e30127554845 (optional)
     * @param  string $teilnehmergruppekuerzel Optionaler Parameter, um zu steuern, für welche Teilnehmergruppe die Veranstaltungstermine abgerufen werden sollen. Ist eine Teilnehmergruppe angegeben, so werden alle in der Zukunft liegenden und publizierten Veranstaltungen für diese Teilnehmergruppe zurückgegeben. (optional)
     * @param  string $veranstaltungskategorie_id Optionaler Parameter, um Veranstaltungstermine nach einer Veranstaltungskategorie zu filtern. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVeranstaltungstermineUsingGET1AsyncWithHttpInfo($modifiziert_ab = null, $stornierte_termine_abrufen = null, $veranstaltungstyp_id = null, $teilnehmergruppekuerzel = null, $veranstaltungskategorie_id = null)
    {
        $returnType = '\Swagger\Client\Model\Veranstaltungstermin[]';
        $request = $this->getVeranstaltungstermineUsingGET1Request($modifiziert_ab, $stornierte_termine_abrufen, $veranstaltungstyp_id, $teilnehmergruppekuerzel, $veranstaltungskategorie_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getVeranstaltungstermineUsingGET1'
     *
     * @param  \DateTime $modifiziert_ab Änderungs- bzw. Einfügezeitpunkt, ab dem die Veranstaltungstermine geliefert werden sollen. Das Format muss wie folgt sein: yyyy-MM-ddTHH:mm:ss.SSS (optional)
     * @param  bool $stornierte_termine_abrufen Optionaler Parameter, um zu steuern, ob stornierte oder nicht stornierte Veranstaltungstermine abgerufen werden sollen. Der Default ist false. (optional)
     * @param  string $veranstaltungstyp_id Optionaler Parameter, um nur Veranstaltungstermine eines bestimmten Veranstaltungstyps abzurufen. Beispiel-ID: cfa1403a-13c6-4681-8ee3-e30127554845 (optional)
     * @param  string $teilnehmergruppekuerzel Optionaler Parameter, um zu steuern, für welche Teilnehmergruppe die Veranstaltungstermine abgerufen werden sollen. Ist eine Teilnehmergruppe angegeben, so werden alle in der Zukunft liegenden und publizierten Veranstaltungen für diese Teilnehmergruppe zurückgegeben. (optional)
     * @param  string $veranstaltungskategorie_id Optionaler Parameter, um Veranstaltungstermine nach einer Veranstaltungskategorie zu filtern. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getVeranstaltungstermineUsingGET1Request($modifiziert_ab = null, $stornierte_termine_abrufen = null, $veranstaltungstyp_id = null, $teilnehmergruppekuerzel = null, $veranstaltungskategorie_id = null)
    {

        $resourcePath = '/v2/20010/veranstaltungstermine';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($modifiziert_ab !== null) {
            $queryParams['modifiziertAb'] = ObjectSerializer::toQueryValue($modifiziert_ab);
        }
        // query params
        if ($stornierte_termine_abrufen !== null) {
            $queryParams['stornierteTermineAbrufen'] = ObjectSerializer::toQueryValue($stornierte_termine_abrufen);
        }
        // query params
        if ($veranstaltungstyp_id !== null) {
            $queryParams['veranstaltungstypID'] = ObjectSerializer::toQueryValue($veranstaltungstyp_id);
        }
        // query params
        if ($teilnehmergruppekuerzel !== null) {
            $queryParams['teilnehmergruppekuerzel'] = ObjectSerializer::toQueryValue($teilnehmergruppekuerzel);
        }
        // query params
        if ($veranstaltungskategorie_id !== null) {
            $queryParams['veranstaltungskategorieId'] = ObjectSerializer::toQueryValue($veranstaltungskategorie_id);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
